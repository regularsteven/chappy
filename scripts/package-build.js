const fs = require('node:fs');
const os = require('node:os');
const path = require('node:path');
const { spawnSync } = require('node:child_process');

const PROJECT_ROOT = path.resolve(__dirname, '..');
const DIST_DIR = path.join(PROJECT_ROOT, 'dist');
const ARTIFACTS_DIR = path.join(PROJECT_ROOT, 'artifacts');

const REQUIRED_PATHS = [
  'dist',
  'main',
  'resources',
  'package.json',
  'package-lock.json',
  'README.md'
];

const now = new Date();
const pad = (value) => String(value).padStart(2, '0');
const timestamp = [
  now.getFullYear(),
  pad(now.getMonth() + 1),
  pad(now.getDate()),
  '-',
  pad(now.getHours()),
  pad(now.getMinutes()),
  pad(now.getSeconds())
].join('');

const zipFileName = `chappy-build-${timestamp}.zip`;
const zipFilePath = path.join(ARTIFACTS_DIR, zipFileName);
const tempRoot = fs.mkdtempSync(path.join(os.tmpdir(), 'chappy-package-'));
const packageRootName = 'chappy-build';
const packageRoot = path.join(tempRoot, packageRootName);

const run = (command, args, options = {}) => {
  const result = spawnSync(command, args, { encoding: 'utf8', ...options });
  if (result.error) {
    throw result.error;
  }
  if (result.status !== 0) {
    if (result.stdout) {
      process.stdout.write(result.stdout);
    }
    if (result.stderr) {
      process.stderr.write(result.stderr);
    }
    throw new Error(`${command} ${args.join(' ')} failed with exit code ${result.status}`);
  }
};

if (!fs.existsSync(DIST_DIR)) {
  console.error(`❌ Missing build output: ${DIST_DIR}`);
  console.error('Run `npm run build` only after Vite has produced dist/.');
  process.exit(1);
}

try {
  fs.mkdirSync(ARTIFACTS_DIR, { recursive: true });
  fs.mkdirSync(packageRoot, { recursive: true });

  for (const relativePath of REQUIRED_PATHS) {
    const source = path.join(PROJECT_ROOT, relativePath);
    if (!fs.existsSync(source)) {
      throw new Error(`Missing required path for packaging: ${source}`);
    }
    const destination = path.join(packageRoot, relativePath);
    fs.cpSync(source, destination, { recursive: true });
  }

  const testingNotes = [
    '# Chappy Test Build',
    '',
    '1. `npm install`',
    '2. `npm run postinstall`',
    '3. `npx electron .`',
    '',
    'This archive is generated by `npm run build`.'
  ].join('\n');

  fs.writeFileSync(path.join(packageRoot, 'TESTING.md'), `${testingNotes}\n`, 'utf8');

  if (fs.existsSync(zipFilePath)) {
    fs.rmSync(zipFilePath, { force: true });
  }

  if (process.platform === 'darwin') {
    run('ditto', ['-c', '-k', '--norsrc', '--keepParent', packageRoot, zipFilePath], {
      env: { ...process.env, COPYFILE_DISABLE: '1' }
    });
  } else {
    run('zip', ['-r', zipFilePath, packageRootName], { cwd: tempRoot });
  }

  console.log(`✅ Build ZIP created: ${zipFilePath}`);
} catch (error) {
  console.error('❌ Failed to create build ZIP.');
  console.error(error.message);
  process.exit(1);
} finally {
  fs.rmSync(tempRoot, { recursive: true, force: true });
}
